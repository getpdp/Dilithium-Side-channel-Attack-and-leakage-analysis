#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "randombytes.h"
#include "sign.h"
#include "polyvec.h"

#include "hal.h"
#include "simpleserial.h"

#define MLEN 33
#define NTESTS 1

  //这是官方的消息用来验证
  //uint8_t m[MLEN] = {0xD8,0x1C,0x4D,0x8D,0x73,0x4F,0xCB,0xFB,0xEA,0xDE,0x3D,0x3F,0x8A,0x03,0x9F,0xAA,0x2A,0x2C,0x99,0x57,0xE8,0x35,0xAD,0x55,0xB2,0x2E,0x75,0xBF,0x57,0xBB,0x55,0x6A,0xC8};
  uint8_t m[MLEN] = {0};//这里不要修改
  uint8_t sm[MLEN + CRYPTO_BYTES]; //签名后的 2420 + MLEN = 2453
  uint8_t m2[MLEN + CRYPTO_BYTES];
  uint8_t pk[CRYPTO_PUBLICKEYBYTES];//1312 = 5* 255+37
  uint8_t sk[CRYPTO_SECRETKEYBYTES];//2544
  //这是官方的seed用来验证
  //uint8_t SEED[SEEDBYTES]={0x7c,0x99,0x35,0xa0,0xb0,0x76,0x94,0xaa,0x0c,0x6d,0x10,0xe4,0xdb,0x6b,0x1a,0xdd,0x2f,0xd8,0x1a,0x25,0xcc,0xb1,0x48,0x03,0x2d,0xcd,0x73,0x99,0x36,0x73,0x7f,0x2d};  //32

  //这是batch0的seed
  //uint8_t SEED[SEEDBYTES] = {0x06,0x10,0x67,0x8f,0xf4,0xdc,0x31,0x28,0xe1,0x61,0x9f,0x91,0x5d,0xc1,0x92,0xc2,0x20,0xf8,0xfa,0xd9,0x4d,0xa1,0x94,0x3b,0x90,0xaa,0xec,0x40,0x16,0x83,0xa4,0x92};
  //uint8_t SEED[SEEDBYTES] = {0xef,0x99,0x22,0x4a,0x03,0xa8,0x5a,0x46,0xef,0x11,0x54,0x74,0xec,0x5b,0x5d,0x62,0x0d,0xa6,0x79,0x5d,0x6e,0xfc,0xca,0x4c,0x91,0x35,0xd1,0x99,0x58,0xa9,0xde,0x62};
  //uint8_t SEED[SEEDBYTES] = {0x9f,0x52,0xaf,0x92,0xca,0x16,0x5f,0xdc,0x38,0x78,0x8f,0x2b,0x59,0xba,0x02,0xe0,0x1c,0x82,0x81,0xff,0x7c,0x1e,0x60,0x50,0x46,0x88,0x04,0x3a,0x5f,0xe8,0x14,0xb0};
  //uint8_t SEED[SEEDBYTES] = {0x61,0x0a,0xfb,0x64,0xbe,0x8c,0xc1,0xdf,0x28,0x8c,0xfb,0x01,0x6e,0xe2,0xf4,0x4c,0x6c,0x07,0x11,0x3d,0xe7,0xf6,0xfe,0xe0,0x71,0xfe,0x0c,0x3f,0xe3,0x1c,0x62,0x15};
    uint8_t SEED[SEEDBYTES] = {0x3e,0x80,0x9e,0xc8,0xdd,0x0f,0xec,0x0d,0x91,0x1a,0x4e,0x3f,0xac,0x20,0xf7,0x0f,0xbb,0x12,0x8c,0x5d,0xe9,0x4d,0xc7,0x18,0x4c,0xa7,0x31,0x0a,0xe9,0x15,0x7a,0x98};
uint8_t recv_0(uint8_t* data, uint8_t dlen)
{
  simpleserial_put('1', 4, sm+255*0);
  return 0;
}


uint8_t recv_9(uint8_t* data, uint8_t dlen)
{
  simpleserial_put('k', 4, sm+MLEN + CRYPTO_BYTES - 4);
  return 0;
}

uint8_t recv_final(uint8_t* data, uint8_t dlen)
{ 
  uint8_t dst[8] = {0};
  memcpy(dst, sm+255*0, 4);
  memcpy(dst+4, sm+MLEN + CRYPTO_BYTES - 4, 4);
  simpleserial_put('c', 8, dst);
  return 0;
}


//////////////////////////////

uint8_t dst[8] = {0};
uint8_t rhoprime[CRHBYTES];
poly y;
uint8_t main_func(uint8_t* data, uint8_t dlen)
{
  
  unsigned int i, j;
  int ret;
  size_t mlen, smlen;
  uint16_t nonce=0;
  

  ////////////////////////
  //!!!!!!!!!!!!!!!!!!!!!!!L*nonce + i
  
    //randombytes(m, MLEN); 随机数
    memcpy(rhoprime, data, CRHBYTES);
    memcpy((uint8_t*)&nonce, data+CRHBYTES, 2);

   
    poly_uniform_gamma1(&y, rhoprime, nonce);

  

 

  	//simpleserial_put('r', 4, (uint8_t*)sm);// 这个没有问题

    
    memcpy(dst, (uint8_t *)y.coeffs, 16);
    memcpy(dst+16, (uint8_t *)y.coeffs + 256 * 4 - 16, 16);
    simpleserial_put('r', 32, (uint8_t *)dst);
    
  return 0;
}


int main(void)
{	
	platform_init();
	init_uart();
	trigger_setup();	
	simpleserial_init();
  
  //59 + 32 = 91
	simpleserial_addcmd('z', 50, main_func);
  //simpleserial_addcmd('a', 1, recv_0);
  // simpleserial_addcmd('b', 1, recv_1);
  // simpleserial_addcmd('c', 1, recv_2);
  // simpleserial_addcmd('d', 1, recv_3);
  // simpleserial_addcmd('e', 1, recv_4);
  // simpleserial_addcmd('f', 1, recv_5);
  // simpleserial_addcmd('g', 1, recv_6);
  // simpleserial_addcmd('h', 1, recv_7);
  // simpleserial_addcmd('i', 1, recv_8);
  // simpleserial_addcmd('j', 1, recv_9);
  // simpleserial_addcmd('b', 1, recv_final);



//  uint8_t data[2] = {1,0};
// 	test(data);
	while(1)
		simpleserial_get();
  	return 0;
}